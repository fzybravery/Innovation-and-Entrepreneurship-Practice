
# SM2 公钥密码算法实现、优化与安全性分析报告

---

## 1. 项目概述

### 1.1. 项目目标

本项目旨在对国家商用密码算法 **SM2** 进行全面的实现、分析与评估。基于 Python 语言，我们不仅构建了 SM2 加密、解密、签名、验签的完整流程，还深入探讨了其核心运算——**标量乘（Scalar Multiplication）**——的多种性能优化与安全增强技术。

本项目从实现、优化和安全三个维度展开：
1.  **实现层面**: 提供了 SM2 算法的完整 Python 实现（`full_sm2.py`），并展示了如何使用 `gmssl` 库进行快速集成（`simple_sm2.py`）。
2.  **优化层面**: 剖析并实现了多种标量乘优化算法，包括使用**雅可比坐标（Jacobian Coordinates）**避免模逆运算，以及通过 **wNAF (windowed Non-Adjacent Form)** 方法和**蒙哥马利梯（Montgomery Ladder）**算法提升性能与安全性。
3.  **安全层面**: 通过代码复现（`sm2_PoC.py`）了针对 SM2 数字签名方案的多种致命攻击，这些攻击均源于对临时随机数 `k` 的不当使用，深刻揭示了 SM2 安全实现的要点。

### 1.2. 技术背景

* **密码体制**: `SM2 公钥密码算法`
    * SM2 是由中国国家密码管理局发布的椭圆曲线公钥密码算法标准，包含数字签名、密钥交换和公钥加密等部分。它基于**椭圆曲线离散对数问题（ECDLP）**的困难性，是保障中国信息安全基础设施的核心密码算法之一。
* **数学基础**: **椭圆曲线密码学 (Elliptic Curve Cryptography, ECC)**
    * ECC 使用定义在有限域 $\mathbb{F}_p$ 上的椭圆曲线方程 $y^2 \equiv x^3 + ax + b \pmod{p}$。曲线上的点与一个特殊的无穷远点 $\mathcal{O}$ 构成一个阿贝尔群，其上的“加法”运算（点加和倍点）是 SM2 的基础。
* **核心难题**: **标量乘**
    * ECC 的核心运算是标量乘，即计算点 $P = k \cdot G$，其中 $G$ 是基点，$k$ 是一个整数（私钥），$P$ 是公钥。该运算的效率和安全性直接决定了 SM2 算法的整体性能和抗攻击能力。

---

## 2. SM2 算法核心原理

### 2.1. 椭圆曲线点运算

SM2 的所有运算都构建于椭圆曲线上的点运算。
* **点加 (Point Addition)**: 两个不同点 $P$ 和 $Q$ 相加得到点 $R$。几何上，它是过 $P, Q$ 的直线与曲线的第三个交点关于 x 轴的对称点。
* **倍点 (Point Doubling)**: 一个点 $P$ 与自身相加。几何上，它是点 $P$ 的切线与曲线的另一个交点关于 x 轴的对称点。
* **标量乘 (Scalar Multiplication)**: 计算 $k \cdot P$ 就是将 $k$ 个 $P$ 点相加。最基础的实现方法是**Double-and-Add**算法。

```python
# full_sm2.py: 基础的 Double-and-Add 标量乘实现
def scalar_mult(k, P):
    R = None
    Q = P
    while k:
        if k & 1: # 如果 k 的当前位是 1，则执行加法
            R = point_add(R, Q)
        Q = point_add(Q, Q) # 每次都执行倍点
        k >>= 1
    return R
```

### 2.2. SM2 加密/解密方案

SM2 采用混合加密方案，结合了 ECC 的非对称加密和对称加密的效率。
* **加密过程 (`full_sm2.py`)**:
    1.  选择一个随机数 $k \in [1, n-1]$。
    2.  计算椭圆曲线点 $C_1 = k \cdot G = (x_1, y_1)$。
    3.  计算会话密钥点 $k \cdot P_B = (x_2, y_2)$，其中 $P_B$ 是接收方的公钥。
    4.  使用密钥派生函数（KDF）从 $x_2, y_2$ 派生出对称加密密钥 $t$。
    5.  用 $t$ 对明文 $M$ 进行异或加密，得到密文 $C_2 = M \oplus t$。
    6.  计算哈希值 $C_3 = \text{Hash}(x_2 || M || y_2)$ 用于校验。
    7.  最终密文是 $C_1 || C_3 || C_2$ 的拼接。

* **解密过程 (`full_sm2.py`)**:
    1.  从密文中分离出 $C_1=(x_1, y_1), C_3, C_2$。
    2.  用私钥 $d_B$ 计算会话密钥点 $d_B \cdot C_1 = d_B \cdot (k \cdot G) = k \cdot (d_B \cdot G) = k \cdot P_B = (x_2, y_2)$。
    3.  用同样的 KDF 派生出对称密钥 $t$。
    4.  解密 $M' = C_2 \oplus t$。
    5.  计算哈希值 $u = \text{Hash}(x_2 || M' || y_2)$，若 $u=C_3$ 则解密成功。

### 2.3. SM2 数字签名方案

* **签名过程 (`sm2_PoC.py`)**:
    1.  计算待签消息 $M$ 的哈希值 $e = \text{Hash}(M)$。
    2.  选择一个随机数 $k \in [1, n-1]$。
    3.  计算椭圆曲线点 $(x_1, y_1) = k \cdot G$。
    4.  计算 $r = (e + x_1) \pmod{n}$。若 $r=0$ 或 $r+k=n$，则重新选择 $k$。
    5.  计算 $s = ((1+d)^{-1} \cdot (k - r \cdot d)) \pmod{n}$。若 $s=0$，则重新选择 $k$。
    6.  签名结果为 $(r, s)$。

* **验证过程**:
    1.  校验 $r, s \in [1, n-1]$。
    2.  计算 $e = \text{Hash}(M)$。
    3.  计算 $t = (r+s) \pmod n$。
    4.  计算点 $(x_1, y_1) = s \cdot G + t \cdot P_A$，其中 $P_A$ 是签名者的公钥。
    5.  计算 $R = (e+x_1) \pmod n$。
    6.  若 $R=r$，则签名有效。

---

## 3. 标量乘性能优化技术

标量乘是 ECC 中最耗时的运算。标准仿射坐标系下的点加/倍点运算每次都需要一次模逆（`mod_inv`），这是非常慢的。

### 3.1. 雅可比坐标 (`jacobian.py`)

* **思路**: 将仿射坐标 $(x, y)$ 映射到射影坐标 $(X, Y, Z)$，其中 $x = X/Z^2, y = Y/Z^3$。在雅可比坐标下，点加和倍点运算可以只用域上的乘法和加法完成，完全避免了昂贵的模逆运算。只有在标量乘全部完成后，才需要进行一次模逆将结果从雅可比坐标转换回仿射坐标。
* **实现**: `jacobian.py` 中实现了 `jacobian_add` 和 `jacobian_double` 函数，它们不包含模逆。`scalar_mult_jacobian` 在循环中调用这些函数，最后调用 `jacobian_to_affine` 完成转换。
* **优势**: 大幅提升标量乘的计算速度，是所有高性能 ECC 实现的基础。

### 3.2. wNAF 方法 (`wNAF.py`)

* **思路**: Double-and-Add 算法的性能取决于标量 $k$ 的汉明权重（二进制表示中'1'的个数）。wNAF 是一种特殊的标量表示法，它引入了负数（如-1, -3）并保证任意 `w` 个连续的系数中最多只有一个非零。这使得其非零项密度远低于二进制表示，从而减少了点加运算的次数。
* **实现**:
    1.  `compute_wnaf(k, w)`: 将标量 `k` 转换为 wNAF 表示。
    2.  `precompute_wnaf_table(P, w)`: 预计算少量基点的倍点（如 $P, 3P, 5P, ...$）并存储起来。
    3.  `scalar_mult_wnaf`: 遍历 wNAF 表示，遇到非零项时，直接从预计算表中查找对应的点并执行点加。
* **优势**: 通过预计算，显著减少了昂贵的点加运算次数，进一步提升了标量乘性能。`w` 的值越大，预计算开销越大，但加速效果越好，需要权衡。

### 3.3. 蒙哥马利梯 (`Montgomery.py`)

* **思路**: 传统的 Double-and-Add 算法中，`if bit == '1'` 的分支操作会导致其在处理 '0' 和 '1' 时，执行的指令序列和时间有差异。攻击者可以通过测量功耗或时间差异（即**侧信道攻击**）来推断私钥 `k` 的比特位。蒙哥马利梯通过一种巧妙的算法设计，确保无论当前比特是 '0' 还是 '1'，每次循环都执行一次点加和一次倍点，使得外部观测完全一致。
* **实现**:
    ```python
    def montgomery_ladder(k, P):
        R0 = INF
        R1 = (P[0], P[1], 1)
        for bit in bin(k)[2:]:
            if bit == '0':
                R1 = jacobian_add(R0, R1)
                R0 = jacobian_double(R0)
            else:
                R0 = jacobian_add(R0, R1)
                R1 = jacobian_double(R1)
        return jacobian_to_affine(R0)
    ```
* **优势**: 提供了对简单侧信道攻击（Simple Power Analysis, SPA）的内在防护，是构建安全 ECC 实现的重要技术。

---

## 4. SM2 签名方案的安全性分析

SM2 签名的安全性**极度依赖**于每笔签名所用的临时随机数 `k` 的**保密性、随机性**和**唯一性**。`sm2_PoC.py` 文件中的代码证明了任何对 `k` 的不当处理都会导致灾难性的私钥泄露。

### 4.1. 攻击一：随机数 `k` 泄露

* **场景**: 如果在某次签名后，随机数 `k` 被泄露。
* **原理**: 签名公式为 $s = ((1+d)^{-1} \cdot (k - r \cdot d)) \pmod{n}$。在这个方程中，除了私钥 `d`，其他所有值（`s`, `r`, `k`）都是已知的。这是一个关于 `d` 的简单线性方程，可以直接求解。
    $$
    d = (k-s)(s+r)^{-1} \pmod n
    $$
* **代码复现**: `sm2_PoC.py` 中的 `recover_from_k` 函数实现了该攻击，并成功恢复了私钥。

### 4.2. 攻击二：重用随机数 `k`

* **场景**: 如果同一个私钥 `d` 对两个不同的消息 $M_1, M_2$ 签名时，使用了相同的随机数 `k`。
* **原理**: 攻击者可以获得两组签名 $(r_1, s_1)$ 和 $(r_2, s_2)$。
    $$
    s_1 = ((1+d)^{-1} \cdot (k - r_1 \cdot d)) \pmod{n}
    $$
    $$
    s_2 = ((1+d)^{-1} \cdot (k - r_2 \cdot d)) \pmod{n}
    $$
    这是一个包含两个未知数 `d` 和 `k` 的线性方程组。通过消元法可以消去 `k`，直接解出 `d`。
    $$
    d = (s_2 - s_1)(r_1 - r_2 + s_1 - s_2)^{-1} \pmod n
    $$
* **代码复现**: `sm2_PoC.py` 中的 `recover_from_reused_k` 函数实现了该攻击。这是历史上真实发生过的著名攻击，曾导致索尼 PlayStation 3 的签名密钥被破解。

### 4.3. 攻击三：多用户共享 `k`

* **场景**: 如果两个不同的用户（私钥为 $d_A, d_B$）在签名时，偶然或恶意地使用了相同的随机数 `k`。
* **原理**: 这种情况等同于 `k` 泄露。用户 A 可以用自己的私钥 $d_A$ 和签名 $(r_A, s_A)$ 计算出 $k = s_A(1+d_A) + r_A d_A$。一旦 `k` 被恢复，用户 A 就可以用这个 `k` 和用户 B 的签名 $(r_B, s_B)$ 来计算出用户 B 的私钥 $d_B$。
* **代码复现**: `sm2_PoC.py` 中的 `recover_shared_k` 演示了这一过程。

---

## 5. 结论

本项目通过 Python 实践，对 SM2 公钥密码算法进行了从基础原理到高级优化，再到安全实践的全面剖析。

* **实现与优化**: SM2 的核心是椭圆曲线上的标量乘。使用雅可比坐标避免模逆是基础优化，而 wNAF 和蒙哥马利梯等算法则分别在性能和抗侧信道攻击方面提供了进一步的增强。
* **安全性**: SM2 算法本身是安全的，但其签名的安全性与实现细节高度相关。**必须确保每次签名使用的随机数 `k` 都是通过密码学安全的伪随机数生成器（CSPRNG）产生，并且绝不重复使用或泄露**。任何对 `k` 的不当处理都会直接导致私钥的彻底泄露。
* **应用启示**: 在工程实践中，应优先使用经过广泛审查和测试的标准化密码库（如 `gmssl`），避免自行实现底层密码原语，以防止因实现不当而引入严重的安全漏洞。
