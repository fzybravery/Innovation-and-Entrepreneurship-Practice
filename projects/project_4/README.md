# SM3 密码哈希算法实现、优化与安全性分析报告

---

## 1. 项目概述

### 1.1. 项目目标

本项目旨在对国家商用密码算法 **SM3** 进行深度分析、实现与评估。通过 C++ 语言，我们实现了 SM3 算法的多种高性能版本，探讨了包括**循环展开（Loop Unrolling）**、**即时计算（On-the-Fly）**和**单指令多数据流（SIMD）**在内的多种优化策略。

此外，本项目还从应用和安全两个维度对 SM3 进行了探索：
1.  **应用层面**: 构建了基于 SM3 的 **Merkle 树**，并演示了其包含性证明的生成过程。
2.  **安全层面**: 实现了针对 SM3 所基于的 Merkle-Damgård 结构的**长度扩展攻击（Length Extension Attack）**，以揭示其内在的安全特性。

### 1.2. 技术背景

* **哈希算法**: `SM3`
    * SM3 是由中国国家密码管理局发布的密码哈希函数标准，用于替代 MD5 和 SHA-1，其安全性和 SHA-256 相当。它广泛应用于数字签名、消息认证码、伪随机数生成等多种密码学场景。
* **算法结构**: **Merkle-Damgård 结构**
    * SM3 遵循经典的 Merkle-Damgård 结构。该结构将任意长度的输入消息分割成固定大小的块，并通过一个核心的**压缩函数（Compression Function）**对这些块进行迭代处理，最终输出固定长度的哈希值。
* **优化技术**:
    * **循环展开**: 一种编译器优化技术，通过减少循环的迭代次数和判断开销来提升性能。
    * **On-the-Fly 计算**: 一种内存优化技术，通过环形缓冲区减少中间状态的存储需求。
    * **SIMD (AVX2)**: 利用现代 CPU 的并行计算能力，同时对多个数据执行相同的操作，是实现高性能计算的关键。

---

## 2. SM3 算法核心原理

SM3 算法处理的消息块大小为 512 位（64 字节），输出的哈希摘要长度为 256 位（32 字节）。其核心流程包括消息填充和迭代压缩。

### 2.1. 消息填充 (Padding)

为了确保任何长度的消息都能被处理成整数个 512 位的块，需要进行填充。步骤如下：
1.  在消息末尾附加一个比特 `1`。
2.  继续填充 `k` 个比特 `0`，直到消息的总长度（以比特为单位）模 512 的余数为 448。
3.  在末尾附加一个 64 位的整数，该整数表示原始消息的长度（以比特为单位）。

填充后的消息长度是 512 比特的整数倍。

### 2.2. 迭代压缩

迭代过程的核心是压缩函数 $CF$。该函数接收一个 256 位的链式变量（Chaining Variable）$V_i$ 和一个 512 位的消息块 $B_i$，并输出一个新的 256 位链式变量 $V_{i+1}$。
$$
V_{i+1} = CF(V_i, B_i)
$$
整个哈希过程从一个固定的初始向量（Initial Vector, IV）开始，对所有消息块进行迭代，最后一个输出 $V_n$ 就是最终的哈希值。

### 2.3. 压缩函数 $CF$ 详解

压缩函数是 SM3 的心脏，其内部包含 64 轮迭代。主要步骤如下：

1.  **消息扩展 (Message Expansion)**:
    * 将 512 位的消息块 $B_i$ 分割成 16 个 32 位的字 $W_0, W_1, ..., W_{15}$。
    * 通过以下公式将其扩展为 68 个字（$W_0$ 到 $W_{67}$）：
        $$
        W_j = P_1(W_{j-16} \oplus W_{j-9} \oplus \text{ROTL}^{15}(W_{j-3})) \oplus \text{ROTL}^7(W_{j-13}) \oplus W_{j-6} \quad (16 \le j \le 67)
        $$
        其中 $P_1$ 是置换函数。
    * 再生成 64 个字 $W'_j = W_j \oplus W_{j+4}$，用于后续计算。

2.  **状态更新 (State Update)**:
    * 压缩函数内部有 8 个 32 位的寄存器（A, B, C, D, E, F, G, H），其初始值来自上一轮的链式变量 $V_i$。
    * 进行 64 轮迭代（$j=0, ..., 63$），每一轮更新寄存器的值：
        $$
        SS_1 = \text{ROTL}^7(\text{ROTL}^{12}(A) + E + \text{ROTL}^j(T_j))
        $$
        $$
        SS_2 = SS_1 \oplus \text{ROTL}^{12}(A)
        $$
        $$
        TT_1 = FF_j(A, B, C) + D + SS_2 + W'_j
        $$
        $$
        TT_2 = GG_j(E, F, G) + H + SS_1 + W_j
        $$
        然后寄存器进行移位赋值：$D \leftarrow C, C \leftarrow \text{ROTL}^9(B), B \leftarrow A, A \leftarrow TT_1, H \leftarrow G, G \leftarrow \text{ROTL}^{19}(F), F \leftarrow E, E \leftarrow P_0(TT_2)$。
    * 最终，将 8 个寄存器的值与输入的 $V_i$ 进行异或，得到输出 $V_{i+1}$。

---

## 3. 实现与性能优化分析

基于您提供的 C++ 代码，我们分析了以下几种实现策略。

### 3.1. 即时计算 (On-the-Fly) 优化 (`sm3_otf.cpp`)

* **思路**: 标准的 SM3 实现在消息扩展时需要一个包含 68 个 `uint32_t` 的数组 `W`。这会占用 `68 * 4 = 272` 字节的栈空间。`sm3_otf` 的实现通过观察发现，计算 $W_j$ 只需要用到前面第 3, 6, 9, 13, 16 个位置的值。因此，我们不需要存储整个 `W` 数组，只需要一个 16 个元素的**环形缓冲区**即可。
* **实现**:
    ```cpp
    // on‐the‐fly：16 深度环形缓冲
    void SM3_OTF::compress(uint32_t H[8], const uint8_t block[64]){
        uint32_t Wbuf[16];
        // ...
        for(int j=0;j<64;j++){
            uint32_t Wj;
            if(j<16){
                Wj = Wbuf[j];
            } else {
                // 使用位运算 `&15` 实现环形访问
                uint32_t X = Wbuf[(j-16)&15] ^ Wbuf[(j-9)&15] ^ rotl(Wbuf[(j-3)&15],15);
                Wj = P1(X) ^ rotl(Wbuf[(j-13)&15],7) ^ Wbuf[(j-6)&15];
                Wbuf[j&15] = Wj; // 将新计算的值存回环形缓冲区
            }
            // ...
        }
    }
    ```
* **优势**: 显著降低了压缩函数内部的内存占用，对于内存受限的嵌入式设备尤其有价值。

### 3.2. 循环展开优化 (`unroll_sm3.cpp`)

* **思路**: 现代 CPU 的流水线和指令级并行能力很强，但循环本身（条件判断、计数器增减）会带来开销，并可能阻碍编译器的进一步优化。通过**手动展开**压缩函数中的 64 轮循环，可以消除这些开销。
* **实现**:
    ```cpp
    // 定义一个宏来表示单轮运算
    #define SM3_ROUND(i, A, B, C, D, E, F, G, H) { ... }

    void SM3_UNROLLED::compress(...) {
        // ... 消息扩展 ...
        
        // 手动展开 64 轮
        SM3_ROUND( 0,A,B,C,D,E,F,G,Ht);
        SM3_ROUND( 1,A,B,C,D,E,F,G,Ht);
        // ... 重复 64 次 ...
        SM3_ROUND(63,A,B,C,D,E,F,G,Ht);
        
        // ... 更新 IV ...
    }
    ```
* **优势**: 减少了分支预测失败的风险，并为编译器提供了更大的代码块来进行指令重排和优化，从而提升执行速度。缺点是会增加最终二进制文件的大小。

### 3.3. SIMD 并行优化 (`sm3_simd.cpp`)

* **思路**: SIMD（单指令多数据）技术允许 CPU 在一个指令周期内对多个数据执行相同的操作。AVX2 是 Intel 的一种 SIMD 指令集，使用 256 位的寄存器（`__m256i`），可以同时容纳 8 个 32 位整数。虽然 SM3 的迭代具有很强的依赖性，看似难以并行，但其内部的置换函数 `P0` 和 `P1` 等是无状态的，可以被向量化。
* **实现**:
    ```cpp
    #ifdef __AVX2__
    // 对 __m256i 中的 8 个 uint32 同时循环左移 n 位
    inline __m256i SM3_SIMD::rotl256(__m256i x, int n) {
        return _mm256_or_si256(_mm256_slli_epi32(x, n), _mm256_srli_epi32(x, 32 - n));
    }

    // 向量化 P1: x ⊕ (x≪15) ⊕ (x≪23)
    inline __m256i SM3_SIMD::P1_256(__m256i x) {
        return _mm256_xor_si256(x,
               _mm256_xor_si256(rotl256(x, 15), rotl256(x, 23)));
    }
    #endif
    ```
    在 `sm3_simd.cpp` 的实现中，虽然整个压缩循环没有被并行化，但在计算消息扩展 `W[j]` 和轮函数中的 `SS1` 时，利用了 AVX2 指令来加速其中的部分运算。这是一种细粒度的优化。
* **优势**: 在支持 AVX2 的 CPU 上，即使是这种细粒度的优化也能带来可观的性能提升。要实现更大程度的并行，通常需要同时处理多个独立消息的哈希计算。

---

## 4. 安全性与应用分析

### 4.1. 安全性：长度扩展攻击 (`SM3_Length_Extented_Attack.cpp`)

* **原理**: 长度扩展攻击是所有采用纯粹 Merkle-Damgård 结构的哈希函数的固有特性。攻击者在不知道原始消息 `M` 的情况下，如果能获得 `M` 的哈希值 `H(M)` 和 `M` 的长度 `len(M)`，就可以计算出 `H(M || padding || M')` 的值，其中 `padding` 是标准填充，`M'` 是攻击者选择的任意后缀。
* **攻击流程**:
    1.  攻击者获得目标哈希 `H(M)` 和 `len(M)`。
    2.  攻击者将 `H(M)` 的 32 字节摘要解析为 8 个 `uint32_t`，并将其作为 SM3 压缩函数的**初始 IV**。
    3.  攻击者构造一个新的消息，即他想附加的后缀 `M'`。
    4.  攻击者以步骤 2 中伪造的 IV 为起点，对 `M'` 进行标准的 SM3 哈希计算。
    5.  最终得到的哈希值，就是 `H(M || padding || M')` 的有效哈希。
* **代码分析**: `SM3_Length_Extented_Attack.cpp` 文件精确地模拟了这一过程。它首先计算 `userid=1234` 的哈希，然后利用这个哈希值和原始长度，成功计算出了一个更长消息 `userid=1234 || padding || &admin=true` 的哈希，而全程无需知道原始消息 `userid=1234`。
* **防范**: 要防范此攻击，常见的做法是采用 `HMAC` 结构，或者使用 `SHA-3`、`BLAKE2` 等不受此攻击影响的现代哈希算法。在 SM3 的应用中，也可以采用双重哈希 `H(H(M))` 或 `H(key || M)` 的形式。

### 4.2. 应用：Merkle 树 (`sm3_merkle.cpp`)

* **原理**: Merkle 树（或哈希树）是一种数据结构，它能够高效、安全地校验大规模数据集的完整性。树的叶子节点是数据块的哈希，而非叶子节点是其子节点哈希的拼接后再哈希。树的根节点（Merkle Root）是对整个数据集的紧凑摘要。
* **代码分析**: `sm3_merkle.cpp` 实现了 Merkle 树的构建和**包含性证明（Inclusion Proof）**的生成。
    1.  **构建**: 对 100,000 个叶子数据（`"leaf_0"`, `"leaf_1"`, ...）分别计算 SM3 哈希，得到叶子节点。然后层层向上合并哈希，直到生成唯一的根哈希。
    2.  **证明**: 为了证明某个叶子（如 `leaf_12345`）确实存在于树中，我们只需要提供从该叶子到根节点的路径上所有**兄弟节点**的哈希即可。这个路径就是“包含性证明”或“审计路径”。验证者可以用这个路径和叶子本身的哈希，独立地重新计算出根哈希，并与已知的根哈希进行比对。
* **意义**: Merkle 树是区块链等分布式系统的核心技术，它允许轻客户端在不下载全部数据的情况下，验证某笔交易是否存在。

---

## 5. 结论

本项目通过 C++ 实践，全面展示了 SM3 哈希算法的内部机理、多种性能优化手段、关键安全特性以及实际应用。

* **性能**: 循环展开和 SIMD 向量化是提升 SM3 计算速度的有效手段，而 On-the-Fly 技术则在内存优化方面表现出色。在实际工程中，可以根据目标平台（高性能服务器 vs. 嵌入式设备）选择合适的优化组合。
* **安全**: 长度扩展攻击的演示清晰地揭示了 Merkle-Damgård 结构的固有弱点，强调了在实际应用中正确使用哈希函数（如配合 HMAC）的重要性。
* **应用**: Merkle 树的实现展示了 SM3 作为密码学基础构件的强大能力，是构建更复杂安全系统的基石。

